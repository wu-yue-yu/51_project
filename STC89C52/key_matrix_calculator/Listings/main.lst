C51 COMPILER V9.60.0.0   MAIN                                                              01/22/2022 21:56:04 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG PRINT(.\Listings\main.lst) OB
                    -JECT(.\Objects\main.obj)

line level    source

   1          /*
   2           * @Descripttion: ç®€æ˜“å››åˆ™è¿ç®—è®¡ç®—å™¨ï¼ˆå‚ä¸è¿ç®—çš„æ•°ã€æœ€ç»ˆç»“æœå’Œä¸­é—´ç»“æœéƒ½åªèƒ½ä
             -¸ºè‡ªç„¶æ•°ï¼Œä¸æ”¯æŒè¿ç®—ä¼˜å…ˆçº§åˆ¤æ–­ï¼Œåªèƒ½æŒ‰ç…§è¾“å…¥é¡ºåºä¾æ¬¡è®¡ç®—ï¼‰
   3           * @Author: äº”æœˆé›¨
   4           * @Date: 2022-01-21 15:33:38
   5           * @LastEditors: äº”æœˆé›¨
   6           * @LastEditTime: 2022-01-22 21:10:56
   7           * @Board: æ¸…ç¿”51å¼€å‘æ¿
   8           * @Chip: STC89C52
   9           */
  10          #include <STC89C5xRC.H>
  11          
  12          sbit SEG = P2^6;                        //æ•°ç ç®¡ä½é€‰
  13          sbit DIG = P2^7;                        //æ•°ç ç®¡æ®µé€‰
  14          sbit KEY_ROW_1 = P3^0;
  15          sbit KEY_ROW_2 = P3^1;
  16          sbit KEY_ROW_3 = P3^2;
  17          sbit KEY_ROW_4 = P3^3;
  18          sbit KEY_COL_1 = P3^4;     
  19          sbit KEY_COL_2 = P3^5;
  20          sbit KEY_COL_3 = P3^6;
  21          sbit KEY_COL_4 = P3^7;
  22          
  23          unsigned char code LedChar[] = {        //æ•°ç ç®¡æ˜¾ç¤ºå­—ç¬¦è½¬æ¢è¡¨
  24              0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 
  25              0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71
  26          };
  27          unsigned char LedBuf[] = {              //æ•°ç ç®¡æ˜¾ç¤ºç¼“å†²åŒº
  28              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  29          };
  30          unsigned char code KeyCodeMap[4][4] = { //æŒ‰é”®æ˜ å°„
  31              {0x31, 0x32, 0x33, 0x25},           /*  1    2    3    +  */
  32              {0x34, 0x35, 0x36, 0x26},           /*  4    5    6    -  */
  33              {0x37, 0x38, 0x39, 0x27},           /*  7    8    9    *  */
  34              {0x30, 0x1B, 0x0D, 0x28}            /*  0    CE   =    /  */
  35          };
  36          unsigned char KeySta[4][4] = {          //æŒ‰é”®å½“å‰çŠ¶æ€å­˜å‚¨
  37              {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}
  38          };
  39          
  40          //è¿ç®—ç§ç±»æ ‡è®°å˜é‡
  41          bit flag_add = 0;
  42          bit flag_sub = 0;
  43          bit flag_mul = 0;
  44          bit flag_div = 0;
  45          //ä»¥ä¸‹å˜é‡å®šä¹‰ä¸ºå…¨å±€å˜é‡æ–¹ä¾¿å‡½æ•°çš„ç¼–å†™
  46          unsigned long result = 0;                //ä¿å­˜è¿ç®—ç»“æœ
  47          unsigned long op = 0;                    //ä¿å­˜å‚ä¸è¿ç®—çš„æ•°å­—
  48          unsigned char cnt_opration = 0;          //è®°å½•è¿ç®—æ¬¡æ•°ï¼Œç”¨äºå¤šæ¬¡è¿ç®—ä¸­åˆ¤æ–­æ˜¯å¦éœ€è¦è®¡
             -ç®—ä¸­é—´ç»“æœ
  49          
  50          void ShowNumber(unsigned long num);
  51          void DoCalculate();
  52          void KeyAction(unsigned char keycode);
C51 COMPILER V9.60.0.0   MAIN                                                              01/22/2022 21:56:04 PAGE 2   

  53          void KeyDriver();
  54          void LedScan(unsigned char x);
  55          void KeyScan();
  56          
  57          void main()
  58          {
  59   1          EA = 1;                     //ä½¿èƒ½æ€»ä¸­æ–­
  60   1          TMOD = 0x01;                //ä½¿ç”¨å®šæ—¶å™¨0çš„å·¥ä½œæ¨¡å¼1
  61   1          TH0 = 0xFC;                 //ä¸­æ–­é—´éš”æ—¶é—´ä¸º1ms
  62   1          TL0 = 0x67;
  63   1          ET0 = 1;                    //ä½¿èƒ½T0ä¸­æ–­
  64   1          TR0 = 1;                    //å¼€å¯T0
  65   1          LedBuf[7] = LedChar[0];     //ä¸Šç”µæ˜¾ç¤º0
  66   1      
  67   1          while (1)
  68   1          {
  69   2              KeyDriver();
  70   2          }
  71   1      }
  72          
  73          /* å°†ä¸€ä¸ªæ— ç¬¦å·é•¿æ•´å½¢çš„æ•°å­—æ˜¾ç¤ºåˆ°æ•°ç ç®¡ä¸Šï¼Œnumä¸ºå¾…æ˜¾ç¤ºæ•°å­— */
  74          void ShowNumber(unsigned long num)
  75          {
  76   1          signed char i;              //æ³¨æ„ä½¿ç”¨æœ‰ç¬¦å·ç±»å‹é˜²æ­¢æº¢å‡º
  77   1          unsigned char buf[8];       //æ˜¾ç¤ºè½¬æ¢ç¼“å†²åŒº
  78   1          for(i = 7; i >= 0; i--)     //å°†numè½¬æ¢ä¸ºæ•°ç»„è¡¨ç¤ºï¼Œæ­¤å¤„æ•°ç»„ä¸­é€†åºå­˜æ”¾æ•°å­—æ˜¯ä¸ºäº†
             -ä¾¿äºåé¢éå†
  79   1          {
  80   2              buf[i] = num % 10;
  81   2              num /= 10;
  82   2          }
  83   1          for(i = 0; i <= 6; i++)      //å»é™¤å‰ç¼€0
  84   1          {
  85   2              if(buf[i] == 0)
  86   2                  LedBuf[i] = 0x00;
  87   2              else
  88   2                  break;
  89   2          }
  90   1          for( ; i <= 7; i++)         //å‰©ä½™ä½ä½è½¬æ¢ä¸ºæ•°ç ç®¡æ˜¾ç¤ºå­—ç¬¦
  91   1          {
  92   2              LedBuf[i] = LedChar[buf[i]];
  93   2          }
  94   1      }
  95          
  96          /* è¿ç®—æ‰§è¡Œå‡½æ•°ï¼Œæ ¹æ®è¿ç®—ç§ç±»æ ‡è®°å˜é‡æ¥æ‰§è¡Œ */
  97          void DoCalculate()
  98          {
  99   1          if(flag_add)
 100   1          {
 101   2              result += op;
 102   2              flag_add = 0;
 103   2          }
 104   1          else if(flag_sub)
 105   1          {
 106   2              result -= op;
 107   2              flag_sub = 0;
 108   2          }
 109   1          else if(flag_mul)
 110   1          {
 111   2              result *= op;
 112   2              flag_mul = 0;
 113   2          }
C51 COMPILER V9.60.0.0   MAIN                                                              01/22/2022 21:56:04 PAGE 3   

 114   1          else if(flag_div)
 115   1          {
 116   2              result /= op;
 117   2              flag_div = 0;
 118   2          }
 119   1      }
 120          
 121          /* æŒ‰é”®åŠ¨ä½œå‡½æ•°ï¼Œæ ¹æ®é”®ç æ‰§è¡Œç›¸åº”çš„æ“ä½œï¼Œkeycodeä¸ºæŒ‰é”®é”®ç  */
 122          void KeyAction(unsigned char keycode)
 123          {
 124   1          if((keycode >= 0x30) && (keycode <= 0x39))  //è¾“å…¥0~9çš„æ•°å­—
 125   1          {
 126   2              op = (op * 10) + (keycode - 0x30);
 127   2              ShowNumber(op);
 128   2          }
 129   1          else if(keycode == 0x25)    //åŠ æ³•è¿ç®—
 130   1          {
 131   2              if(cnt_opration > 0)    //è‹¥å¼å­ä¸­è¿ç®—æ¬¡æ•°å¤§äºä¸€ï¼Œå…ˆè¿›è¡Œä¸€æ¬¡è¿ç®—
 132   2              {
 133   3                  DoCalculate();      //å¾—åˆ°çš„è¿ç®—ç»“æœç”¨äºè¿›è¡Œä¸‹ä¸€æ¬¡è¿ç®—
 134   3                  cnt_opration--;
 135   3              }
 136   2              else
 137   2              {
 138   3                  result = op;        //å°†opçš„å€¼å­˜å‚¨åˆ°resultä¸­ï¼Œä¾¿äºç¬¬äºŒä¸ªè¿ç®—æ•°çš„è¾“å…¥
 139   3              } 
 140   2              flag_add = 1;           //æ ‡è®°æœ‰ä¸€æ¬¡åŠ è¿ç®—éœ€è¦æ‰§è¡Œ
 141   2              cnt_opration++;         //ç­‰å¾…æ‰§è¡Œçš„è¿ç®—æ•°é‡åŠ ä¸€
 142   2              op = 0;                 //æ¸…é›¶opå˜é‡ï¼Œä»¥å­˜å‚¨ä¸‹ä¸€ä¸ªè¿ç®—æ•°çš„è¾“å…¥
 143   2          }
 144   1          else if(keycode == 0x26)    //å‡æ³•è¿ç®—
 145   1          {
 146   2              if(cnt_opration > 0)
 147   2              {
 148   3                  DoCalculate();
 149   3                  cnt_opration--;
 150   3              }
 151   2              else
 152   2              {
 153   3                  result = op;
 154   3              } 
 155   2              flag_sub = 1;
 156   2              cnt_opration++;
 157   2              op = 0; 
 158   2          }
 159   1          else if(keycode == 0x27)    //ä¹˜æ³•è¿ç®—
 160   1          {
 161   2              if(cnt_opration > 0)
 162   2              {
 163   3                  DoCalculate();
 164   3                  cnt_opration--;
 165   3              }
 166   2              else
 167   2              {
 168   3                  result = op;
 169   3              } 
 170   2              flag_mul = 1;
 171   2              cnt_opration++;
 172   2              op = 0;
 173   2          }
 174   1          else if(keycode == 0x28)    //é™¤æ³•è¿ç®—
 175   1          {
C51 COMPILER V9.60.0.0   MAIN                                                              01/22/2022 21:56:04 PAGE 4   

 176   2              if(cnt_opration > 0)
 177   2              {
 178   3                  DoCalculate();
 179   3                  cnt_opration--;
 180   3              }
 181   2              else
 182   2              {
 183   3                  result = op;
 184   3              } 
 185   2              flag_div = 1;
 186   2              cnt_opration++;
 187   2              op = 0;
 188   2          }
 189   1          else if(keycode == 0x0D)    //ç­‰å·
 190   1          {
 191   2              DoCalculate();
 192   2              ShowNumber(result);
 193   2              result = 0;
 194   2              cnt_opration = 0;
 195   2              op = 0;
 196   2          }
 197   1          else if (keycode == 0x1B)   //æ ‡å‡†è®¡ç®—å™¨ä¸­çš„CEæ“ä½œ
 198   1          {
 199   2              op = 0;
 200   2              ShowNumber(op);
 201   2          }
 202   1      }
 203          
 204          /* æŒ‰é”®é©±åŠ¨å‡½æ•°ï¼Œæ£€æµ‹æŒ‰é”®åŠ¨ä½œï¼Œè°ƒåº¦ç›¸åº”åŠ¨ä½œå‡½æ•° */
 205          void KeyDriver()
 206          {
 207   1          unsigned char i, j;
 208   1          static unsigned char backup[4][4] = {    //æŒ‰é”®çŠ¶æ€å¤‡ä»½ï¼Œä¿å­˜å‰ä¸€æ¬¡çš„å€¼
 209   1              {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}
 210   1          };
 211   1      
 212   1          //çŸ©é˜µé”®ç›˜æŒ‰é”®çŠ¶æ€å¾ªç¯æ£€æµ‹
 213   1          for(i = 0; i < 4; i++)
 214   1          {
 215   2              for(j = 0; j < 4; j++)
 216   2              {
 217   3                  if(backup[i][j] != KeySta[i][j]) //æ£€æµ‹æŒ‰é”®çŠ¶æ€å˜åŒ–ï¼Œè‹¥è¿™ä¸€æ¬¡ä¸å‰ä¸€æ¬¡çŠ¶æ€ä¸
             -åŒï¼Œåˆ™æŒ‰é”®äº§ç”Ÿäº†åŠ¨ä½œï¼Œä»è€Œæ ¹æ®éœ€è¦æ¥æ‰§è¡Œæ“ä½œ
 218   3                  {
 219   4                      if(backup[i][j] != 0)        //è‹¥è¯¥æŒ‰é”®æŒ‰ä¸‹
 220   4                      {
 221   5                          KeyAction(KeyCodeMap[i][j]);
 222   5                      }
 223   4                      backup[i][j] = KeySta[i][j];
 224   4                  }
 225   3              }
 226   2          }
 227   1      }
 228          
 229          /* æŒ‰é”®æ‰«æå‡½æ•°ï¼Œéœ€è¦åœ¨å®šæ—¶ä¸­æ–­ä¸­è°ƒç”¨ */
 230          void KeyScan()
 231          {
 232   1          unsigned char keycol;                                    //çŸ©é˜µæŒ‰é”®æ‰«æåˆ—ç´¢å¼•
 233   1          static unsigned char keyrow = 0;                         //çŸ©é˜µæŒ‰é”®æ‰«æè¡Œç´¢å¼•
 234   1          static unsigned char keybuf[4][4] = {                    //çŸ©é˜µæŒ‰é”®çŠ¶æ€ç¼“å†²åŒº
 235   1              {0xFF, 0xFF, 0xFF, 0xFF}, {0xFF, 0xFF, 0xFF, 0xFF},
 236   1              {0xFF, 0xFF, 0xFF, 0xFF}, {0xFF, 0xFF, 0xFF, 0xFF}
C51 COMPILER V9.60.0.0   MAIN                                                              01/22/2022 21:56:04 PAGE 5   

 237   1          };
 238   1      
 239   1          //å°†å½“å‰è¡Œçš„æ¯ä¸ªæŒ‰é”®çŠ¶æ€å­˜å…¥ç¼“å†²åŒºä¸­
 240   1          keybuf[keyrow][0] = (keybuf[keyrow][0] << 1) | KEY_COL_1;
 241   1          keybuf[keyrow][1] = (keybuf[keyrow][1] << 1) | KEY_COL_2;
 242   1          keybuf[keyrow][2] = (keybuf[keyrow][2] << 1) | KEY_COL_3;
 243   1          keybuf[keyrow][3] = (keybuf[keyrow][3] << 1) | KEY_COL_4;
 244   1      
 245   1          //ç”±äºæœºæ¢°æŒ‰é”®çš„æŠ–åŠ¨æ—¶é—´ä¸€èˆ¬åœ¨10mså†…
 246   1          //æ­¤å¤„æ‰«æé’ˆå¯¹äºæ¯ä¸ªæŒ‰é”®è¿ç»­é‡‡æ ·å››æ¬¡ï¼Œé‡‡æ ·æ—¶é—´ä¸º1ms
 247   1          //ç”±äºæ¯æ¬¡ä¸­æ–­åªæ‰«æä¸€è¡Œï¼Œä¸‹åˆ—åˆ¤æ–­æˆç«‹çš„æ¡ä»¶ä¸º
 248   1          //å½“ä¸€ä¸ªæŒ‰é”®è¿ç»­16msä¿æŒæŒ‰ä¸‹æˆ–å¼¹èµ·ï¼Œåˆ™å¯è®¤ä¸ºæŒ‰é”®å°±æ˜¯æŒ‰ä¸‹æˆ–å¼¹èµ·çŠ¶æ€
 249   1          //è¿™æ ·æ—¢æ£€æµ‹åˆ°äº†æŒ‰é”®çŠ¶æ€ï¼Œåˆèƒ½è¾¾åˆ°å»æŠ–æ•ˆæœ
 250   1          for(keycol = 0; keycol < 4; keycol++)
 251   1          {
 252   2              if((keybuf[keyrow][keycol] & 0x0F) == 0x00)          //æŒ‰é”®æŒ‰ä¸‹
 253   2                  KeySta[keyrow][keycol] = 0;
 254   2              else if((keybuf[keyrow][keycol] & 0x0F) == 0x0F)     //æŒ‰é”®å¼¹èµ·
 255   2                  KeySta[keyrow][keycol] = 1;
 256   2          }
 257   1      
 258   1          keyrow++;                                                //å‡†å¤‡è¿›è¡Œä¸‹ä¸€è¡Œçš„æ‰«æ
 259   1          keyrow = keyrow & 0x03;                                  //æ§åˆ¶è¡Œç´¢å¼•åœ¨0~3ä»¥å†…å˜åŒ–
 260   1          switch(keyrow)                                           //æ ¹æ®è¡Œç´¢å¼•æ”¹å˜ç”µå¹³ï¼Œä»¥è¿›è¡Œå¯¹å
             -º”æŸè¡ŒæŒ‰é”®çš„æ‰«æ
 261   1          {
 262   2              case 0: KEY_ROW_4 = 1; KEY_ROW_1 = 0; break;
 263   2              case 1: KEY_ROW_1 = 1; KEY_ROW_2 = 0; break;
 264   2              case 2: KEY_ROW_2 = 1; KEY_ROW_3 = 0; break;
 265   2              case 3: KEY_ROW_3 = 1; KEY_ROW_4 = 0; break;
 266   2              default: break;
 267   2          }
 268   1      }
 269          
 270          /* æ•°ç ç®¡åŠ¨æ€æ‰«æåˆ·æ–°æ˜¾ç¤ºå‡½æ•°ï¼Œéœ€åœ¨å®šæ—¶å™¨ä¸­æ–­ä¸­è°ƒç”¨ */
 271          void LedScan(unsigned char x)
 272          {
 273   1          P0 = 0x00;      //é˜²æ­¢äº§ç”Ÿäº¤æ›¿é‡å½±
 274   1          SEG = 1;
 275   1          SEG = 0;
 276   1      
 277   1          P0 = 0xFF;      //ä½æ¶ˆéš
 278   1          DIG = 1;
 279   1          P0 &= ~(1 << x);
 280   1          DIG = 0;
 281   1          
 282   1          P0 = 0x00;      //æ®µæ¶ˆéš
 283   1          SEG = 1;
 284   1          P0 = LedBuf[x];
 285   1          SEG = 0;
 286   1      }
 287          
 288          /* T0ä¸­æ–­æœåŠ¡å‡½æ•°ï¼Œç”¨äºæ•°ç ç®¡æ˜¾ç¤ºæ‰«æä¸æŒ‰é”®æ‰«æ */
 289          void InterruptTimer0() interrupt 1
 290          {
 291   1          static unsigned idx = 0;                        //æ•°ç ç®¡æ‰«æä½ç´¢å¼•
 292   1          
 293   1          TH0 = 0xFC;                                     //T0å€¼é‡è½½
 294   1          TL0 = 0x67;
 295   1      
 296   1          LedScan(idx);
 297   1          if(idx < 7)
C51 COMPILER V9.60.0.0   MAIN                                                              01/22/2022 21:56:04 PAGE 6   

 298   1              idx++;
 299   1          else 
 300   1              idx = 0;
 301   1          KeyScan();
 302   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1094    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     68      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
