C51 COMPILER V9.60.0.0   MAIN                                                              02/04/2022 18:26:54 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG PRINT(.\Listings\main.lst) OB
                    -JECT(.\Objects\main.obj)

line level    source

   1          /*
   2           * @Descripttion: å®ç°ä¸€ä¸ªå®ç”¨ç§’è¡¨ï¼ˆç²¾ç¡®åˆ°0.01sï¼‰ï¼Œå¯ä»¥å¯åœã€å¤ä½ç§’è¡¨ã€‚åªæ˜¾ç¤ºæœ
             -‰æ•ˆä½ã€‚
   3           * @Author: äº”æœˆé›¨
   4           * @Date: 2022-01-13 16:36:08
   5           * @LastEditors: äº”æœˆé›¨
   6           * @LastEditTime: 2022-01-31 11:56:33
   7           * @Board: æ¸…ç¿”51å¼€å‘æ¿
   8           * @Chip: STC89C52
   9           */
  10          #include <STC89C5xRC.H>
  11          
  12          sbit SEG = P2^6;                    //æ®µé€‰
  13          sbit DIG = P2^7;                    //ä½é€‰
  14          sbit KEY_S2 = P3^0;                 
  15          sbit KEY_S3 = P3^1;
  16          sbit KEY_S4 = P3^2;
  17          sbit KEY_S5 = P3^3;
  18          
  19          unsigned char code LedChar[] = {    //æ•°ç ç®¡æ˜¾ç¤ºå­—ç¬¦è½¬æ¢è¡¨
  20              0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07,
  21              0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71
  22          };
  23          unsigned char LedBuf[] = {          //æ•°ç ç®¡æ˜¾ç¤ºç¼“å†²åŒº
  24              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  25          };
  26          unsigned char KeyStaCur[] = {       //æŒ‰é”®å½“å‰çŠ¶æ€
  27              1, 1, 1, 1
  28          };
  29          
  30          bit StopwatchRunning = 0;           //ç§’è¡¨è¿è¡ŒçŠ¶æ€æ ‡å¿—
  31          bit StopwatchRefresh = 1;           //ç§’è¡¨è®¡æ•°åˆ·æ–°æ ‡å¿—ï¼Œåˆå§‹ä¸º1ï¼Œä»¥åˆ·æ–°æ˜¾ç¤ºåˆå€¼
  32          unsigned char DecimalPart = 0;      //ç§’è¡¨è®¡æ—¶å°æ•°éƒ¨åˆ†
  33          unsigned int IntegerPart = 0;       //ç§’è¡¨è®¡æ—¶æ•´æ•°éƒ¨åˆ†
  34          //ä¸‹åˆ—å†™æ³•ä¾¿äºæ›´æ”¹å®šæ—¶å™¨ä¸­æ–­é—´éš”ï¼ˆå®šæ—¶å™¨åˆå§‹åŒ–é…ç½®è¿‡ç¨‹å†™ä¸ºå‡½æ•°ï¼‰
  35          unsigned char T0RH = 0;             //T0é‡è£…å€¼çš„é«˜å­—èŠ‚
  36          unsigned char T0RL = 0;             //T0é‡è£…å€¼çš„ä½å­—èŠ‚
  37          
  38          void ConfigTimer0ms(unsigned int ms);
  39          void StopwatchDisplay();
  40          void StopwatchAction();
  41          void StopwatchReset();
  42          void KeyDriver();
  43          void LedScan();
  44          void KeyScan();
  45          void StopwatchCount();
  46          
  47          void main()
  48          {
  49   1          EA = 1;
  50   1          ConfigTimer0ms(2);  //T0å®šæ—¶ä¸º2msï¼ˆç‹¬ç«‹é”®ç›˜æ‰«æ2msè¶³å¤Ÿå¿«ï¼‰
  51   1      
  52   1          while(1)
  53   1          {
C51 COMPILER V9.60.0.0   MAIN                                                              02/04/2022 18:26:54 PAGE 2   

  54   2              if(StopwatchRefresh)
  55   2              {
  56   3                  StopwatchRefresh = 0;
  57   3                  StopwatchDisplay();
  58   3              }
  59   2              KeyDriver();
  60   2          }
  61   1      }
  62          
  63          /* å®šæ—¶å™¨åˆå§‹åŒ–å‡½æ•° */
  64          void ConfigTimer0ms(unsigned int ms)
  65          {
  66   1          unsigned long tmp;
  67   1          tmp = 11059200 / 12;
  68   1          tmp = (tmp * ms) / 1000;
  69   1          tmp = 65536 - tmp;
  70   1          tmp += 21;              //è¡¥å¿ä¸­æ–­ç›¸åº”å»¶æ—¶é€ æˆçš„è¯¯å·®ï¼Œè¯¯å·®å¯é€šè¿‡keilæµ‹å¾—
  71   1          TMOD = 0x01;
  72   1          /*
  73   1          å¯ä»¥å†™æˆè¿™ç§å½¢å¼é˜²æ­¢å½±å“åˆ°tmodçš„å…¶ä»–ä½ï¼Œä½†è¿™é‡Œæ²¡å¿…è¦
  74   1          TMOD &= 0xF0;
  75   1          TMOD |= 0x01;
  76   1          */
  77   1          T0RH = (unsigned char)(tmp >> 8);
  78   1          T0RL = (unsigned char)tmp;
  79   1          ET0 = 1;
  80   1          TR0 = 1;
  81   1      }
  82          
  83          /* ç§’è¡¨è®¡æ•°è½¬æ¢ä¸ºæ•°ç ç®¡æ˜¾ç¤ºå­—ç¬¦å‡½æ•° */
  84          void StopwatchDisplay()
  85          {
  86   1          unsigned char i;
  87   1          unsigned char buf[4];
  88   1      
  89   1          LedBuf[7] = LedChar[DecimalPart % 10];       //è¿™é‡Œå°æ•°éƒ¨åˆ†éƒ½éœ€è¦æ˜¾ç¤º
  90   1          LedBuf[6] = LedChar[DecimalPart / 10];       //æ‰€ä»¥ä¸éœ€è¦æ”¾åˆ°ç¼“å†²åŒº
  91   1      
  92   1          buf[3] = IntegerPart % 10;          //æ”¾å…¥ç¼“å†²åŒºï¼Œé¿å…å½±å“Ledbufä¸­çš„æ•°æ®
  93   1          buf[2] = (IntegerPart/10) % 10;
  94   1          buf[1] = (IntegerPart/100) % 10;
  95   1          buf[0] = (IntegerPart/1000) % 10;
  96   1      
  97   1          for(i = 0; i <= 2; i++)             //æ— æ•ˆä½ä¸æ˜¾ç¤º
  98   1          {
  99   2              if(buf[i] == 0)
 100   2                  LedBuf[i+2] = 0x00;
 101   2              else
 102   2                  break;
 103   2          }
 104   1          for( ; i <= 3; i++)                 //åªæ˜¾ç¤ºæœ‰æ•ˆä½
 105   1          {
 106   2              LedBuf[i+2] = LedChar[buf[i]];
 107   2          }
 108   1          LedBuf[5] |= (1 << 7);              //ç‚¹äº®å°æ•°ç‚¹
 109   1      }
 110          
 111          /* ç§’è¡¨å¯åœå‡½æ•° */
 112          void StopwatchAction()
 113          {
 114   1          if(StopwatchRunning)
 115   1              StopwatchRunning = 0;
C51 COMPILER V9.60.0.0   MAIN                                                              02/04/2022 18:26:54 PAGE 3   

 116   1          else 
 117   1              StopwatchRunning = 1;
 118   1      }
 119          
 120          /* ç§’è¡¨å¤ä½å‡½æ•° */
 121          void StopwatchReset()
 122          {
 123   1          StopwatchRunning = 0;               //åœæ­¢ç§’è¡¨
 124   1          DecimalPart = 0;                    //æ¸…0è®¡æ•°å€¼
 125   1          IntegerPart = 0;
 126   1          StopwatchRefresh = 1;               //æ ‡è®°è¯·æ±‚å¤ä½
 127   1      }
 128          
 129          /* æŒ‰é”®é©±åŠ¨å‡½æ•° */
 130          void KeyDriver()
 131          {
 132   1          unsigned char i;
 133   1          static unsigned char backup[] = {1, 1, 1, 1};     //å¤‡ä»½ä¸Šä¸€æ¬¡æŒ‰é”®çš„çŠ¶æ€
 134   1      
 135   1          for(i = 0; i < 4; i++)
 136   1          {
 137   2              if(backup[i] != KeyStaCur[i])
 138   2              {
 139   3                  if(KeyStaCur[i] == 0)                   //è‹¥æŒ‰é”®æŒ‰ä¸‹
 140   3                  {
 141   4                      if(i == 1)                          //è‹¥æŒ‰ä¸‹å¤ä½é”®
 142   4                          StopwatchReset();               //å¤ä½ç§’è¡¨
 143   4                      else if(i == 2)                     //è‹¥æŒ‰ä¸‹å¯åœé”®
 144   4                          StopwatchAction();              //å¯åœç§’è¡¨
 145   4                  }
 146   3                  backup[i] = KeyStaCur[i];               //æ›´æ–°å‰ä¸€æ¬¡å¤‡ä»½å€¼
 147   3              }
 148   2          }
 149   1      }
 150          
 151          /* æ•°ç ç®¡åŠ¨æ€æ‰«æå‡½æ•° */
 152          void LedScan()
 153          {
 154   1          static unsigned char idx = 0;
 155   1      
 156   1          P0 = 0x00;          //é¿å…äº§ç”Ÿäº¤æ›¿é‡å½±
 157   1          SEG = 1;
 158   1          SEG = 0;
 159   1      
 160   1          P0 = 0xFF;          //ä½æ¶ˆéš
 161   1          DIG = 1;
 162   1          P0 &= ~(1 << idx);
 163   1          DIG = 0;
 164   1      
 165   1          P0 = 0x00;          //æ®µæ¶ˆéš
 166   1          SEG = 1;
 167   1          P0 = LedBuf[idx];
 168   1          SEG = 0;
 169   1      
 170   1          if(idx < 7)         //æ›´æ–°æ•°ç ç®¡æ‰«æç´¢å¼•
 171   1              idx++;
 172   1          else 
 173   1              idx = 0;
 174   1      }
 175          
 176          /* é”®ç›˜åŠ¨æ€æ‰«æå‡½æ•° */
 177          void KeyScan()
C51 COMPILER V9.60.0.0   MAIN                                                              02/04/2022 18:26:54 PAGE 4   

 178          {
 179   1          unsigned char i;
 180   1          static unsigned char keybuf[] = {
 181   1              0xFF, 0xFF, 0xFF, 0xFF
 182   1          };
 183   1      
 184   1          keybuf[0] = (keybuf[0] << 1) | KEY_S2;
 185   1          keybuf[1] = (keybuf[1] << 1) | KEY_S3;
 186   1          keybuf[2] = (keybuf[2] << 1) | KEY_S4;
 187   1          keybuf[3] = (keybuf[3] << 1) | KEY_S5;
 188   1      
 189   1          //æ‰«æç‹¬ç«‹æŒ‰é”®ï¼Œåªæœ‰4ä¸ªé”®
 190   1          //å–2msé‡‡ç”¨é—´éš”ï¼Œ8æ¬¡è¿ç»­é‡‡æ ·çš„å€¼æ¥åˆ¤æ–­æŒ‰é”®çŠ¶æ€
 191   1          //ä¸€èˆ¬æŒ‰é”®æ—¶é—´ä¸è¶…è¿‡100msï¼Œä¸”ä¸ä½äº40~50ms
 192   1          //è¿™é‡Œ16mså³å¯æ‰«æå®Œæ‰€æœ‰ç‹¬ç«‹æŒ‰é”®
 193   1          //ä½†æ˜¯ç”±äºè¦ä¿è¯æ•°ç ç®¡åŠ¨æ€æ˜¾ç¤ºæ•ˆæœï¼Œå®šæ—¶æ—¶é—´æœ€å¥½ä¸è¶…è¿‡2ms
 194   1          for(i = 0; i < 4; i++)
 195   1          {
 196   2              if(keybuf[i] == 0x00)
 197   2                  KeyStaCur[i] = 0;
 198   2              else if(keybuf[i] == 0xFF)
 199   2                  KeyStaCur[i] = 1;
 200   2          }
 201   1      }
 202          
 203          /* ç§’è¡¨è®¡æ—¶å‡½æ•° */
 204          void StopwatchCount()
 205          {
 206   1          if(StopwatchRunning)                //è‹¥ç§’è¡¨ä»åœ¨è®¡æ•°ï¼Œåˆ™æ›´æ–°è®¡æ•°å€¼
 207   1          {   
 208   2              DecimalPart++;                  //æ»¡10msï¼Œå°æ•°éƒ¨åˆ†åŠ 1
 209   2              if(DecimalPart >= 100)          //æ»¡1000msï¼Œå³æ»¡1s
 210   2              {
 211   3                  IntegerPart++;              //æ•´æ•°éƒ¨åˆ†åŠ 1
 212   3                  DecimalPart = 0;            //å¹¶æŠŠå°æ•°éƒ¨åˆ†æ¸…é›¶
 213   3                  if(IntegerPart >= 10000)    //æ§åˆ¶è®¡æ—¶èŒƒå›´åœ¨0~10000ç§’
 214   3                  {
 215   4                      IntegerPart = 0;
 216   4                  }
 217   3              }
 218   2              StopwatchRefresh = 1;  
 219   2          }         //è®¡æ—¶å€¼æ›´æ–°åï¼Œè®¾ç½®ç§’è¡¨åˆ·æ–°æ ‡å¿—ä¸º1
 220   1      }
 221          
 222          /* ä¸­æ–­æœåŠ¡å‡½æ•°ï¼Œå®Œæˆç§’è¡¨è®¡æ—¶ï¼Œæ•°ç ç®¡å’ŒæŒ‰é”®çš„åŠ¨æ€æ‰«æ*/
 223          void InterruptTimer0() interrupt 1
 224          {
 225   1          static unsigned char timer_2ms = 0;     
 226   1          
 227   1          TH0 = T0RH;                 
 228   1          TL0 = T0RL;
 229   1          
 230   1          LedScan();
 231   1          KeyScan();
 232   1      
 233   1          timer_2ms++;                //ä¸­æ–­ä¸€æ¬¡ä¸º2msï¼Œ5æ¬¡å³ä¸º10ms
 234   1          if(timer_2ms >= 5)          //è®¡æ—¶æ»¡10ms
 235   1          {
 236   2              timer_2ms = 0;
 237   2              StopwatchCount();       //è°ƒç”¨ç§’è¡¨è®¡æ—¶å‡½æ•°
 238   2          }
 239   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              02/04/2022 18:26:54 PAGE 5   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    641    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     27       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
